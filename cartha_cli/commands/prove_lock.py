"""Prove-lock command - submit LockProof payloads."""

from __future__ import annotations

import json
import os
import time
from decimal import Decimal, InvalidOperation
from pathlib import Path
from typing import Any

import typer
from rich import box
from rich.prompt import Confirm
from rich.table import Table
from web3 import Web3

try:
    from eth_account import Account
except ImportError:
    Account = None  # type: ignore

from ..config import settings
from ..display import display_clock_and_countdown
from ..pair import get_uid_from_hotkey
from ..utils import normalize_hex, usdc_to_base_units
from .common import console, exit_with_error, handle_unexpected_exception
from .prove_lock_helpers import (
    generate_eip712_signature,
    send_lock_proof,
    submit_lock_proof_payload,
)
from .prove_lock_payload import load_payload_file
from .prove_lock_signing import (
    collect_external_signature,
    generate_external_signing_files,
)


def prove_lock(
    payload_file: Path | None = typer.Option(  # noqa: B008
        None,
        "--payload-file",
        help="Path to JSON file generated by build_lock_proof.py. If provided, all other parameters are loaded from this file.",
        show_default=False,
    ),
    chain: int | None = typer.Option(
        None,
        "--chain",
        help="EVM chain ID for the vault transaction.",
        show_default=False,
    ),
    vault: str | None = typer.Option(
        None,
        "--vault",
        help="Vault contract address.",
        show_default=False,
    ),
    tx: str | None = typer.Option(
        None,
        "--tx",
        help="Transaction hash for the LockCreated event.",
        show_default=False,
    ),
    amount: str | None = typer.Option(
        None,
        "--amount",
        help="Lock amount in USDC (e.g. 250.5). Auto-detects if normalized USDC or base units (>1e9). When omitted you'll be prompted.",
        show_default=False,
    ),
    hotkey: str | None = typer.Option(
        None,
        "--hotkey",
        help="Bittensor hotkey SS58 address.",
        show_default=False,
    ),
    slot: int | None = typer.Option(
        None,
        "--slot",
        help="Subnet UID assigned to the miner. If not provided, will prompt for input.",
        show_default=False,
    ),
    auto_fetch_uid: bool = typer.Option(
        True,
        "--auto-fetch-uid/--no-auto-fetch-uid",
        help="Automatically fetch UID from Bittensor network (default: enabled). Use --no-auto-fetch-uid to prompt for UID.",
    ),
    miner_evm: str | None = typer.Option(
        None,
        "--miner-evm",
        help="EVM address that signed the LockProof payload.",
        show_default=False,
    ),
    password: str | None = typer.Option(
        None,
        "--pwd",
        help="Pair password used when signing the LockProof payload.",
        show_default=False,
    ),
    signature: str | None = typer.Option(
        None,
        "--signature",
        help="Hex EIP-712 signature.",
        show_default=False,
    ),
    timestamp: int | None = typer.Option(
        None,
        "--timestamp",
        help="Unix timestamp (seconds) used when signing the LockProof. Required when using signature from build_lock_proof.py.",
        show_default=False,
    ),
    json_output: bool = typer.Option(
        False, "--json", help="Emit the verifier response as JSON."
    ),
) -> None:
    """Submit a LockProof derived from the given on-chain deposit."""
    try:
        amount_base_units: int | None = None

        # Load payload file if provided
        pool_id: str | None = None
        if payload_file is not None:
            (
                chain,
                vault,
                tx,
                amount,
                amount_base_units,
                hotkey,
                slot,
                miner_evm,
                password,
                signature,
                timestamp,
                pool_id,
            ) = load_payload_file(
                payload_file,
                chain,
                vault,
                tx,
                amount,
                hotkey,
                slot,
                miner_evm,
                password,
                signature,
                timestamp,
            )
        else:
            # Normalize hex fields if provided via CLI args
            if signature is not None:
                signature = normalize_hex(signature)
                if len(signature) != 132:  # 0x + 130 hex chars = 65 bytes
                    console.print(
                        "[bold red]Error:[/] Signature must be 65 bytes (0x + 130 hex characters)"
                    )
                    raise typer.Exit(code=1)
            if password is not None:
                password = normalize_hex(password)
                if len(password) != 66:  # 0x + 64 hex chars = 32 bytes
                    console.print(
                        "[bold red]Error:[/] Pair password must be 32 bytes (0x + 64 hex characters)"
                    )
                    raise typer.Exit(code=1)
            if tx is not None:
                tx = normalize_hex(tx)
                if len(tx) != 66:  # 0x + 64 hex chars = 32 bytes
                    console.print(
                        "[bold red]Error:[/] Transaction hash must be 32 bytes (0x + 64 hex characters)"
                    )
                    raise typer.Exit(code=1)
            if miner_evm is not None:
                if not Web3.is_address(miner_evm):
                    console.print(
                        "[bold red]Error:[/] Miner EVM address must be a valid EVM address"
                    )
                    raise typer.Exit(code=1)
                miner_evm = Web3.to_checksum_address(miner_evm)
            if vault is not None:
                if not Web3.is_address(vault):
                    console.print(
                        "[bold red]Error:[/] Vault address must be a valid EVM address"
                    )
                    raise typer.Exit(code=1)
                vault = Web3.to_checksum_address(vault)

        # Handle signature collection/generation
        sign_locally: bool | None = None
        private_key_for_signing: str | None = None

        if signature is None:
            has_signature = Confirm.ask(
                "[bold cyan]Do you already have an EIP-712 signature?[/]", default=False
            )

            if has_signature:
                # User has signature - collect it and required fields
                signature = _collect_existing_signature()
                miner_evm = _prompt_miner_evm(miner_evm)
                timestamp = _prompt_timestamp(timestamp)
            else:
                # Need to generate signature
                sign_locally = Confirm.ask(
                    "[bold cyan]Sign locally with private key?[/]", default=True
                )

                if sign_locally:
                    private_key_for_signing, miner_evm = _collect_private_key(miner_evm)
                else:
                    console.print(
                        "\n[bold cyan]You'll need to sign externally. "
                        "We'll collect all fields first, then show you the message to sign.[/]"
                    )

        # Collect all required fields
        chain, vault, tx, amount_base_units, hotkey, slot, password = (
            _collect_required_fields(
                chain,
                vault,
                tx,
                amount,
                amount_base_units,
                hotkey,
                slot,
                password,
                auto_fetch_uid,
            )
        )

        # Generate signature if needed
        if signature is None:
            if sign_locally and private_key_for_signing:
                if timestamp is None:
                    timestamp = int(time.time())

                console.print("\n[dim]Generating EIP-712 signature...[/]")
                try:
                    signature, derived_evm_str = generate_eip712_signature(
                        chain_id=chain,
                        vault_address=vault,
                        miner_hotkey=hotkey,
                        slot_uid=str(slot),
                        tx_hash=tx,
                        amount=amount_base_units,
                        password=password,
                        timestamp=timestamp,
                        private_key=private_key_for_signing,
                    )
                    derived_evm = Web3.to_checksum_address(derived_evm_str)
                    if (
                        miner_evm is not None
                        and miner_evm.lower() != derived_evm.lower()
                    ):
                        console.print(
                            f"[yellow]Warning:[/] EVM address mismatch detected. "
                            f"Expected {miner_evm}, got {derived_evm}"
                        )
                        if not typer.confirm("Continue anyway?", default=False):
                            raise typer.Exit(code=1)
                    console.print("[bold green]✓ Signature generated[/]")
                except Exception as exc:
                    handle_unexpected_exception("Failed to generate signature", exc)
            else:
                # External signing
                if timestamp is None:
                    timestamp = int(time.time())
                miner_evm = _prompt_miner_evm(miner_evm)

                json_filename, txt_filename = generate_external_signing_files(
                    chain=chain,
                    vault=vault,
                    miner_evm=miner_evm,
                    hotkey=hotkey,
                    slot=slot,
                    tx=tx,
                    amount_base_units=amount_base_units,
                    password=password,
                    timestamp=timestamp,
                )

                console.print("\n[bold green]✓ EIP-712 message files generated[/]")
                console.print(f"[bold cyan]JSON file:[/] {json_filename}")
                console.print(f"[bold cyan]Instructions:[/] {txt_filename}")

                signature = collect_external_signature()

        # Ensure miner_evm is set
        if miner_evm is None:
            miner_evm = _prompt_miner_evm(None)

        # Ensure timestamp is set
        if timestamp is None:
            timestamp = int(time.time())

        # Validate all required fields
        assert amount_base_units is not None, "Amount must be set"
        assert chain is not None, "Chain ID must be set"
        assert vault is not None, "Vault address must be set"
        assert tx is not None, "Transaction hash must be set"
        assert hotkey is not None, "Hotkey must be set"
        assert slot is not None, "Slot UID must be set"
        assert miner_evm is not None, "Miner EVM address must be set"
        assert password is not None, "Pair password must be set"
        assert signature is not None, "Signature must be set"
        assert timestamp is not None, "Timestamp must be set"

        # Create payload
        slot_id = str(slot)
        payload = submit_lock_proof_payload(
            chain=chain,
            vault=vault,
            tx_hash=tx,
            amount=amount_base_units,
            hotkey=hotkey,
            slot=slot_id,
            miner_evm=miner_evm,
            password=password,
            signature=signature,
            timestamp=timestamp,
            pool_id=pool_id,  # Include pool_id for verifier demo mode
        )

        # Show summary and confirm
        _show_summary_and_confirm(
            payload, chain, vault, tx, hotkey, slot_id, miner_evm, json_output
        )

        # Submit
        send_lock_proof(payload, json_output)
        if not json_output:
            human_amount = Decimal(payload["amount"]) / Decimal(10**6)
            amount_str = f"{human_amount:.6f}".rstrip("0").rstrip(".")
            console.print("\n[bold green]✓ Lock proof submitted successfully[/]")
            console.print(
                f"[bold cyan]Amount submitted[/]: {amount_str} USDC "
                f"({payload['amount']} base units)"
            )
            console.print(
                "[bold cyan]Reminder[/]: keep your pair password private to prevent USDC theft."
            )
    except typer.Exit:
        raise
    except Exception as exc:
        handle_unexpected_exception("Lock proof submission failed", exc)


def _collect_existing_signature() -> str:
    """Collect existing signature from user."""
    console.print("\n[bold cyan]Please provide your signature and required fields:[/]")
    while True:
        signature = typer.prompt("EIP-712 signature (0x...)", show_default=False)
        signature_normalized = normalize_hex(signature)
        if len(signature_normalized) == 132:
            return signature_normalized
        console.print(
            "[bold red]Error:[/] Signature must be 65 bytes (0x + 130 hex characters)"
        )


def _prompt_miner_evm(miner_evm: str | None) -> str:
    """Prompt for miner EVM address if not provided."""
    if miner_evm is not None:
        return miner_evm
    while True:
        miner_evm = typer.prompt("Miner EVM address", show_default=False)
        if Web3.is_address(miner_evm):
            return Web3.to_checksum_address(miner_evm)
        console.print(
            "[bold red]Error:[/] Miner EVM address must be a valid EVM address (0x...)"
        )


def _prompt_timestamp(timestamp: int | None) -> int:
    """Prompt for timestamp if not provided."""
    if timestamp is not None:
        return timestamp
    console.print(
        "[yellow]Note:[/] The timestamp must match the one used when creating the signature."
    )
    while True:
        try:
            timestamp_input = typer.prompt(
                "Timestamp used when signing (Unix timestamp in seconds)",
                show_default=False,
            )
            timestamp = int(timestamp_input)
            if timestamp <= 0:
                console.print(
                    "[bold red]Error:[/] Timestamp must be a positive integer"
                )
                continue
            return timestamp
        except ValueError:
            console.print("[bold red]Error:[/] Timestamp must be a valid integer")


def _collect_private_key(miner_evm: str | None) -> tuple[str, str]:
    """Collect and validate private key, returning (private_key, miner_evm)."""
    console.print("\n[bold cyan]Please provide your EVM private key:[/]")
    private_key_from_env = os.getenv("CARTHA_EVM_PK")
    if private_key_from_env:
        console.print("[dim]Using CARTHA_EVM_PK from environment variable[/]")
    else:
        console.print(
            "[dim]Tip:[/] Set CARTHA_EVM_PK environment variable to avoid prompting"
        )

    while True:
        private_key = (
            private_key_from_env
            if private_key_from_env
            else typer.prompt(
                "EVM private key (0x...)",
                hide_input=True,
                show_default=False,
            )
        )

        try:
            private_key_normalized = normalize_hex(private_key)
            if len(private_key_normalized) != 66:
                console.print(
                    "[bold red]Error:[/] Private key must be 32 bytes (0x + 64 hex characters)"
                )
                if private_key_from_env:
                    private_key_from_env = None
                continue

            if Account is None:
                exit_with_error(
                    "eth-account is required for EIP-712 signing. Install it with: uv sync"
                )
            account = Account.from_key(private_key_normalized)
            derived_evm = Web3.to_checksum_address(account.address)

            console.print(f"\n[bold cyan]Derived EVM address:[/] {derived_evm}")
            if miner_evm is not None:
                if miner_evm.lower() != derived_evm.lower():
                    console.print(
                        f"[yellow]Warning:[/] Provided EVM address ({miner_evm}) "
                        f"does not match private key address ({derived_evm})"
                    )
                    if not typer.confirm("Continue anyway?", default=False):
                        if private_key_from_env:
                            private_key_from_env = None
                        continue
                else:
                    console.print("[bold green]✓ EVM address matches[/]")
            else:
                if not Confirm.ask(
                    "[bold cyan]Is this your correct EVM address?[/]",
                    default=True,
                ):
                    console.print("[bold yellow]Please use a different private key.[/]")
                    if private_key_from_env:
                        private_key_from_env = None
                    continue
                miner_evm = derived_evm
                console.print("[bold green]✓ EVM address confirmed[/]")

            return private_key_normalized, miner_evm
        except Exception as exc:
            console.print(f"[bold red]Error:[/] Failed to derive EVM address: {exc}")
            if private_key_from_env:
                private_key_from_env = None
            continue


def _collect_required_fields(
    chain: int | None,
    vault: str | None,
    tx: str | None,
    amount: str | None,
    amount_base_units: int | None,
    hotkey: str | None,
    slot: int | None,
    password: str | None,
    auto_fetch_uid: bool,
) -> tuple[int, str, str, int, str, int, str]:
    """Collect all required fields, prompting if missing."""
    # Chain
    if chain is None:
        while True:
            try:
                chain_input = typer.prompt("\nChain ID", show_default=False)
                chain = int(chain_input)
                if chain <= 0:
                    console.print(
                        "[bold red]Error:[/] Chain ID must be a positive integer"
                    )
                    continue
                break
            except ValueError:
                console.print("[bold red]Error:[/] Chain ID must be a valid integer")

    # Vault
    if vault is None:
        while True:
            vault = typer.prompt("Vault contract address", show_default=False)
            if Web3.is_address(vault):
                vault = Web3.to_checksum_address(vault)
                break
            console.print(
                "[bold red]Error:[/] Vault address must be a valid EVM address (0x...)"
            )

    # Transaction hash
    if tx is None:
        while True:
            tx = typer.prompt("Transaction hash", show_default=False)
            tx_normalized = normalize_hex(tx)
            if len(tx_normalized) == 66:
                tx = tx_normalized
                break
            console.print(
                "[bold red]Error:[/] Transaction hash must be 32 bytes (0x + 64 hex characters)"
            )

    # Amount
    if amount_base_units is None:
        if amount is None:
            while True:
                try:
                    normalized_input = typer.prompt(
                        "Lock amount in USDC (e.g. 250.5)", show_default=False
                    )
                    amount_base_units = usdc_to_base_units(normalized_input)
                    if amount_base_units <= 0:
                        console.print("[bold red]Error:[/] Amount must be positive")
                        continue
                    break
                except Exception as exc:
                    console.print(f"[bold red]Error:[/] Invalid amount: {exc}")
        else:
            try:
                amount_as_int = int(float(amount))
                if amount_as_int >= 1_000_000_000:
                    amount_base_units = amount_as_int
                else:
                    amount_base_units = usdc_to_base_units(amount)
            except (ValueError, InvalidOperation):
                amount_base_units = usdc_to_base_units(amount)

    # Hotkey
    if hotkey is None:
        while True:
            hotkey = typer.prompt("Hotkey SS58 address", show_default=False)
            if hotkey.startswith("bt1") or hotkey.startswith("5"):
                if len(hotkey) >= 10:
                    break
            console.print(
                "[bold red]Error:[/] Hotkey must be a valid SS58 address (starts with 'bt1' or '5')"
            )

    # Slot
    if slot is None:
        if auto_fetch_uid:
            if hotkey is None:
                console.print(
                    "[bold red]Error:[/] Cannot fetch UID: hotkey must be provided first."
                )
                raise typer.Exit(code=1)

            console.print("[bold cyan]Fetching UID from subnet...[/]")
            try:
                slot = get_uid_from_hotkey(
                    network=settings.network, netuid=settings.netuid, hotkey=hotkey
                )
                if slot is None:
                    console.print(
                        "[bold yellow]Hotkey is not registered or has been deregistered[/] "
                        f"on netuid {settings.netuid} ({settings.network} network)."
                    )
                    console.print(
                        "[yellow]You do not belong to any UID at the moment.[/] "
                        "Please register your hotkey first using 'cartha miner register'."
                    )
                    raise typer.Exit(code=0)
                console.print(f"[bold green]Found UID: {slot}[/]")
            except typer.Exit:
                raise
            except Exception as exc:
                console.print(
                    "[bold red]Failed to fetch UID automatically[/]: This may be due to Bittensor network issues."
                )
                console.print("[yellow]Falling back to manual input...[/]")
                try:
                    slot_input = typer.prompt("Enter your slot UID", type=int)
                    slot = slot_input
                    console.print(f"[bold green]Using UID: {slot}[/]")
                except (ValueError, KeyboardInterrupt):
                    console.print("[bold red]Invalid UID or cancelled.[/]")
                    raise typer.Exit(code=1) from exc
        else:
            console.print(
                "[bold cyan]UID not provided.[/] "
                "[yellow]Auto-fetch disabled. Enter UID manually.[/]"
            )
            try:
                slot_input = typer.prompt(
                    "Enter your slot UID (from 'cartha miner register' output)",
                    type=int,
                )
                slot = slot_input
                console.print(f"[bold green]Using UID: {slot}[/]")
            except (ValueError, KeyboardInterrupt):
                console.print("[bold red]Invalid UID or cancelled.[/]")
                raise typer.Exit(code=1)

    # Password
    if password is None:
        while True:
            password = typer.prompt(
                "Pair password (0x...)", hide_input=True, show_default=False
            )
            password_normalized = normalize_hex(password)
            if len(password_normalized) == 66:
                password = password_normalized
                break
            console.print(
                "[bold red]Error:[/] Pair password must be 32 bytes (0x + 64 hex characters)"
            )

    return (
        chain,
        vault,
        tx,
        amount_base_units,
        hotkey,
        slot,
        password,
    )


def _show_summary_and_confirm(
    payload: dict[str, Any],
    chain: int,
    vault: str,
    tx: str,
    hotkey: str,
    slot_id: str,
    miner_evm: str,
    json_output: bool,
) -> None:
    """Show summary table and get confirmation."""

    if not json_output:
        human_amount = Decimal(payload["amount"]) / Decimal(10**6)
        amount_str = f"{human_amount:.6f}".rstrip("0").rstrip(".")
        console.print("\n[bold cyan]Lock Proof Summary:[/]")
        summary_table = Table(show_header=False, box=box.SIMPLE)
        summary_table.add_column(style="cyan")
        summary_table.add_column(style="yellow")
        summary_table.add_row("Chain ID", str(chain))
        summary_table.add_row("Vault", vault)
        summary_table.add_row("Transaction", tx)
        summary_table.add_row(
            "Amount", f"{amount_str} USDC ({payload['amount']} base units)"
        )
        summary_table.add_row("Hotkey", hotkey)
        summary_table.add_row("Slot UID", slot_id)
        summary_table.add_row("EVM Address", miner_evm)
        summary_table.add_row(
            "Signature",
            payload["signature"][:20] + "..." + payload["signature"][-10:],
        )
        console.print(summary_table)
        console.print()

        display_clock_and_countdown()
    else:
        console.print(
            f"[dim]Preparing to submit lock proof: "
            f"chain={chain}, vault={vault}, amount={payload['amount']}, "
            f"hotkey={hotkey}, slot={slot_id}[/]"
        )

    if not Confirm.ask(
        "[bold yellow]Submit this lock proof to the verifier?[/]", default=True
    ):
        if json_output:
            console.print(json.dumps({"ok": False, "cancelled": True}))
        else:
            console.print("[bold yellow]Submission cancelled.[/]")
        raise typer.Exit(code=0)
